version: '3.6'

# =============================================================================
# avapigw Test Environment
# =============================================================================
# Port allocation:
#   8200       - Vault (dev mode, root token: myroot)
#   8090/8091  - Keycloak (admin/admin)
#   8801       - REST API 1 (no auth)          - /health, /api/v1/items, /ws
#   8802       - REST API 2 (no auth)          - /health, /api/v1/items, /ws
#   8803       - REST API 3 (OIDC auth)        - validates JWT from Keycloak
#   8804       - REST API 4 (mTLS auth)        - requires client certs from Vault PKI
#   8805       - REST API 5 (basic auth)       - HTTP Basic authentication
#   8811/9091  - gRPC 1 (no auth)              - Unary, ServerStream, BidiStream
#   8812/9092  - gRPC 2 (no auth)              - Unary, ServerStream, BidiStream
#   8813/9093  - gRPC 3 (mTLS auth)            - requires client certs from Vault PKI
#   8814/9094  - gRPC 4 (OIDC auth)            - validates JWT from Keycloak
#   6379       - Redis standalone
#   6380       - Redis master (sentinel)
#   26379-26381 - Redis sentinels
#   3200       - Tempo HTTP API
#   4317/4318  - OTLP receivers
#   8428       - VictoriaMetrics
#   3000       - Grafana
#
# Setup order:
#   1. docker compose up -d
#   2. Wait for Vault and Keycloak to be ready
#   3. Run scripts/setup-vault.sh   (configures PKI, issues certs)
#   4. Run scripts/setup-keycloak.sh (creates realm, clients for service-to-service)
#   5. Restart mTLS/OIDC backends:
#      docker compose restart rest_api_3 rest_api_4 grpc_3 grpc_4
# =============================================================================

services:
  # ===========================================================================
  # Vault - PKI for mTLS certificates
  # ===========================================================================
  vault:
    image: hashicorp/vault:1.17
    container_name: vault
    volumes:
      - vault_data:/vault/file
    environment:
      VAULT_DEV_ROOT_TOKEN_ID: myroot
      VAULT_DEV_LISTEN_ADDRESS: 0.0.0.0:8200
      VAULT_ADDR: http://127.0.0.1:8200
    cap_add:
      - IPC_LOCK
    ports:
      - 8200:8200
    healthcheck:
      test: ["CMD", "vault", "status"]
      interval: 5s
      timeout: 3s
      retries: 10
      start_period: 5s

  # ===========================================================================
  # REST API backends (ghcr.io/vyrodovalexey/restapi-example)
  # Endpoints: /health, /ready, /metrics, /api/v1/items, /ws (WebSocket)
  # Probe port: 9090 (/health, /ready, /metrics without auth)
  # ===========================================================================

  # REST backend 1 - no authentication
  rest_api_1:
    image: ghcr.io/vyrodovalexey/restapi-example:41b1a46
    container_name: rest_api_1
    environment:
      APP_AUTH_MODE: none
      APP_LOG_LEVEL: info
    ports:
      - 8801:8080
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:9090/health"]
      interval: 5s
      timeout: 3s
      retries: 10
      start_period: 5s

  # REST backend 2 - no authentication (for load balancing tests)
  rest_api_2:
    image: ghcr.io/vyrodovalexey/restapi-example:41b1a46
    container_name: rest_api_2
    environment:
      APP_AUTH_MODE: none
      APP_LOG_LEVEL: info
    ports:
      - 8802:8080
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:9090/health"]
      interval: 5s
      timeout: 3s
      retries: 10
      start_period: 5s

  # REST backend 3 - OIDC authentication (service-to-service)
  # Validates JWT tokens issued by Keycloak realm "backend-test"
  # Gateway must obtain a token via client_credentials grant and pass it as Bearer
  rest_api_3:
    image: ghcr.io/vyrodovalexey/restapi-example:41b1a46
    container_name: rest_api_3
    environment:
      APP_AUTH_MODE: oidc
      APP_LOG_LEVEL: debug
      APP_OIDC_ISSUER_URL: http://host.docker.internal:8090/realms/backend-test
      APP_OIDC_CLIENT_ID: restapi-server
    depends_on:
      keycloak_web:
        condition: service_healthy
    ports:
      - 8803:8080

  # REST backend 4 - mTLS authentication
  # Requires client certificates signed by Vault PKI CA
  # Certs are provisioned by scripts/setup-vault.sh into shared volume
  rest_api_4:
    image: ghcr.io/vyrodovalexey/restapi-example:41b1a46
    container_name: rest_api_4
    environment:
      APP_AUTH_MODE: mtls
      APP_LOG_LEVEL: debug
      APP_TLS_ENABLED: "true"
      APP_TLS_CERT_PATH: /certs/rest-server.crt
      APP_TLS_KEY_PATH: /certs/rest-server.key
      APP_TLS_CA_PATH: /certs/ca.crt
      APP_TLS_CLIENT_AUTH: require
    volumes:
      - mtls_certs:/certs:ro
    ports:
      - 8804:8080

  # REST backend 5 - basic authentication
  rest_api_5:
    image: ghcr.io/vyrodovalexey/restapi-example:41b1a46
    container_name: rest_api_5
    environment:
      APP_AUTH_MODE: basic
      APP_LOG_LEVEL: info
      APP_BASIC_AUTH_USERS: "backend-user:$$2y$$05$$7RhNcAD91bWQvRscIZp3E.v9KYFyIT3FV7sBKCVm6Mk3cEQca0AHO"
    ports:
      - 8805:8080
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:9090/health"]
      interval: 5s
      timeout: 3s
      retries: 10
      start_period: 5s

  # ===========================================================================
  # gRPC backends (ghcr.io/vyrodovalexey/grpc-example)
  # Endpoints: Unary, ServerStream, BidirectionalStream
  # Metrics/health port: 9090 (/healthz, /metrics)
  # ===========================================================================

  # gRPC backend 1 - no authentication
  # NOTE: grpc-example uses a distroless image (no shell/wget/curl),
  # so in-container healthchecks are not possible. Health is verified
  # externally via the metrics port 9090 (/healthz).
  grpc_1:
    image: ghcr.io/vyrodovalexey/grpc-example:e6f4e61
    container_name: grpc_1
    environment:
      GRPC_PORT: 8080
      METRICS_PORT: 9090
      LOG_LEVEL: info
      AUTH_MODE: none
    ports:
      - 8811:8080
      - 9091:9090

  # gRPC backend 2 - no authentication (for load balancing tests)
  grpc_2:
    image: ghcr.io/vyrodovalexey/grpc-example:e6f4e61
    container_name: grpc_2
    environment:
      GRPC_PORT: 8080
      METRICS_PORT: 9090
      LOG_LEVEL: info
      AUTH_MODE: none
    ports:
      - 8812:8080
      - 9092:9090

  # gRPC backend 3 - mTLS authentication
  # Requires client certificates signed by Vault PKI CA
  grpc_3:
    image: ghcr.io/vyrodovalexey/grpc-example:e6f4e61
    container_name: grpc_3
    environment:
      GRPC_PORT: 8080
      METRICS_PORT: 9090
      LOG_LEVEL: debug
      AUTH_MODE: mtls
      TLS_ENABLED: "true"
      TLS_MODE: mtls
      TLS_CERT_PATH: /certs/grpc-server.crt
      TLS_KEY_PATH: /certs/grpc-server.key
      TLS_CA_PATH: /certs/ca.crt
      TLS_CLIENT_AUTH: require
    volumes:
      - mtls_certs:/certs:ro
    ports:
      - 8813:8080
      - 9093:9090

  # gRPC backend 4 - OIDC authentication (service-to-service)
  # Validates JWT tokens issued by Keycloak realm "backend-test"
  grpc_4:
    image: ghcr.io/vyrodovalexey/grpc-example:e6f4e61
    container_name: grpc_4
    environment:
      GRPC_PORT: 8080
      METRICS_PORT: 9090
      LOG_LEVEL: debug
      AUTH_MODE: oidc
      OIDC_ENABLED: "true"
      OIDC_ISSUER_URL: http://host.docker.internal:8090/realms/backend-test
      OIDC_CLIENT_ID: grpc-server
    depends_on:
      keycloak_web:
        condition: service_healthy
    ports:
      - 8814:8080
      - 9094:9090

  # ===========================================================================
  # Redis
  # ===========================================================================
  redis:
    image: bitnami/redis:latest
    container_name: redis
    environment:
      REDIS_PASSWORD: password
    volumes:
      - redis_data:/bitnami/redis/data
    ports:
      - 6379:6379

  # Redis Sentinel setup (master + replica + 3 sentinels)
  # NOTE: replica-announce-ip/port tells sentinel the host-reachable address of the master,
  # so that tests running on the host can connect to the master via 127.0.0.1:6380.
  redis-master:
    image: bitnami/redis:latest
    container_name: redis-master
    environment:
      REDIS_REPLICATION_MODE: master
      REDIS_PASSWORD: password
      REDIS_EXTRA_FLAGS: "--replica-announce-ip 127.0.0.1 --replica-announce-port 6380"
    ports:
      - 6380:6379
    volumes:
      - redis_master_data:/bitnami/redis/data

  redis-replica:
    image: bitnami/redis:latest
    container_name: redis-replica
    environment:
      REDIS_REPLICATION_MODE: slave
      REDIS_MASTER_HOST: redis-master
      REDIS_MASTER_PORT_NUMBER: 6379
      REDIS_MASTER_PASSWORD: password
      REDIS_PASSWORD: password
    depends_on:
      - redis-master

  redis-sentinel-1:
    image: bitnami/redis-sentinel:latest
    container_name: redis-sentinel-1
    environment:
      REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS: 5000
      REDIS_SENTINEL_FAILOVER_TIMEOUT: 10000
      REDIS_SENTINEL_QUORUM: 2
      REDIS_MASTER_HOST: redis-master
      REDIS_MASTER_PORT_NUMBER: 6379
      REDIS_MASTER_PASSWORD: password
      REDIS_MASTER_SET: mymaster
      REDIS_SENTINEL_ANNOUNCE_IP: 127.0.0.1
      REDIS_SENTINEL_ANNOUNCE_PORT: 26379
    depends_on:
      - redis-master
      - redis-replica
    ports:
      - 26379:26379

  redis-sentinel-2:
    image: bitnami/redis-sentinel:latest
    container_name: redis-sentinel-2
    environment:
      REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS: 5000
      REDIS_SENTINEL_FAILOVER_TIMEOUT: 10000
      REDIS_SENTINEL_QUORUM: 2
      REDIS_MASTER_HOST: redis-master
      REDIS_MASTER_PORT_NUMBER: 6379
      REDIS_MASTER_PASSWORD: password
      REDIS_MASTER_SET: mymaster
      REDIS_SENTINEL_ANNOUNCE_IP: 127.0.0.1
      REDIS_SENTINEL_ANNOUNCE_PORT: 26380
    depends_on:
      - redis-master
      - redis-replica
    ports:
      - 26380:26379

  redis-sentinel-3:
    image: bitnami/redis-sentinel:latest
    container_name: redis-sentinel-3
    environment:
      REDIS_SENTINEL_DOWN_AFTER_MILLISECONDS: 5000
      REDIS_SENTINEL_FAILOVER_TIMEOUT: 10000
      REDIS_SENTINEL_QUORUM: 2
      REDIS_MASTER_HOST: redis-master
      REDIS_MASTER_PORT_NUMBER: 6379
      REDIS_MASTER_PASSWORD: password
      REDIS_MASTER_SET: mymaster
      REDIS_SENTINEL_ANNOUNCE_IP: 127.0.0.1
      REDIS_SENTINEL_ANNOUNCE_PORT: 26381
    depends_on:
      - redis-master
      - redis-replica
    ports:
      - 26381:26379

  # ===========================================================================
  # Keycloak - OIDC provider for authentication testing
  # ===========================================================================
  keycloak_web:
    image: quay.io/keycloak/keycloak:26.5
    container_name: keycloak_web
    environment:
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://keycloakdb:5432/keycloak
      KC_DB_USERNAME: keycloak
      KC_DB_PASSWORD: password

      KC_HTTP_PORT: 8090
      KC_HOSTNAME_STRICT: false
      KC_HOSTNAME_STRICT_HTTPS: false
      KC_HTTP_ENABLED: true
      KC_PROXY_HEADERS: xforwarded
      KC_FEATURES: token-exchange,admin-fine-grained-authz
      KC_SPI_REALM_DEFAULT_SSL_REQUIRED: none

      KC_LOG_LEVEL: info
      KC_METRICS_ENABLED: true
      KC_HEALTH_ENABLED: true
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
    command: start-dev
    depends_on:
      keycloakdb:
        condition: service_healthy
    ports:
      - 8090:8090
      - 8091:9000
    healthcheck:
      test: ["CMD-SHELL", "exec 3<>/dev/tcp/localhost/9000 && echo -e 'GET /health/ready HTTP/1.1\\r\\nHost: localhost\\r\\nConnection: close\\r\\n\\r\\n' >&3 && cat <&3 | grep -q '\"UP\"'"]
      interval: 10s
      timeout: 5s
      retries: 30
      start_period: 30s

  keycloakdb:
    image: postgres:16
    container_name: keycloakdb
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: keycloak
      POSTGRES_USER: keycloak
      POSTGRES_PASSWORD: password
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U keycloak"]
      interval: 5s
      timeout: 3s
      retries: 10
      start_period: 10s

  # ===========================================================================
  # Observability stack
  # ===========================================================================
  tempo:
    image: grafana/tempo:2.7.1
    container_name: tempo
    command:
      - -config.file=/etc/tempo/tempo.yaml
    volumes:
      - tempo_data:/var/tempo
      - ./tempo/tempo.yaml:/etc/tempo/tempo.yaml:ro
    ports:
      - 3200:3200    # Tempo HTTP API
      - 4317:4317    # OTLP gRPC receiver
      - 4318:4318    # OTLP HTTP receiver

  victoriametrics:
    image: victoriametrics/victoria-metrics:v1.108.1
    container_name: victoriametrics
    ports:
      - 8428:8428
    volumes:
      - victoriametrics_data:/victoria-metrics-data
      - ./victoriametrics/scrape.yml:/etc/victoriametrics/promscrape.yml:ro
    command:
      - --promscrape.config=/etc/victoriametrics/promscrape.yml
      - --storageDataPath=/victoria-metrics-data
      - --httpListenAddr=:8428
      - --retentionPeriod=30d

  grafana:
    image: grafana/grafana:11.5.2
    container_name: grafana
    ports:
      - 3000:3000
    environment:
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: admin
      GF_AUTH_ANONYMOUS_ENABLED: "true"
      GF_AUTH_ANONYMOUS_ORG_ROLE: Viewer
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning:ro
      - ../../monitoring/grafana:/var/lib/grafana/dashboards/avapigw:ro
    depends_on:
      - victoriametrics
      - tempo

volumes:
  postgres_data:
  vault_data:
  redis_data:
  redis_master_data:
  victoriametrics_data:
  grafana_data:
  tempo_data:
  mtls_certs:
